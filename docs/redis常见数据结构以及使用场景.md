# redis

###  常见数据结构和使用场景

#### String

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字，是常规的key-value缓存应用；常规计数：微博数、粉丝数、访问量。

#### Hash

hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。比如我们可以用hash数据结构来存储用户信息、商品信息等等。

#### List

list就是链表（双链表），Redis中List的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表、粉丝列表、消息列表等功能都可以用redis的list结构来实现。

#### Set

set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动重排的。

当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。

比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。

#### ZSet

和set相比，Zset增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

比如：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Zset结构进行存储。

### 设置过期时间

Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。

我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。

如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？

#### 定期删除+惰性删除

通过名字大概就能猜出这两个删除方式的意思了。

- **定期删除**：redis默认是每隔 100ms 就**随机抽取**一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
- **惰性删除** ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！

但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ **redis 内存淘汰机制。**

### redis内存淘汰机制

redis 配置文件 redis.conf 中有相关注释，我这里就不贴了，大家可以自行查阅或者通过这个网址查看： http://download.redis.io/redis-stable/redis.conf

**redis 提供 8种数据淘汰策略：**

1. **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错
7. **volatile-lfu**：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
8. **allkeys-lfu**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

### redis持久化

很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。

redis主要有两种持久化方式：

* 快照持久化
* AOF持久化

[详见这篇文章]([https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/Redis/Redis持久化.md))



### 缓存雪崩和缓存穿透问题解决方案

#### 缓存雪崩

什么是缓存雪崩？

缓存在同一时间大面积失效（比如集体过期），所以以后的请求全部打在了数据库上，造成了数据库在短时间内承受大量请求而崩掉。

例如：对于双十二零点的抢购活动，抢购的商品集中的放在了缓存，假设时间为一个小时，那么到了一点钟的时候这些商品就全部失效了，而对于这一波商品的查询都落到了数据库上面可能导致数据库崩溃。

##### 解决办法？

* 事前：尽量保证整个redis集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
* 事中：本地缓存+限流+降级，避免mysql崩掉
* 事后：利用redis持久化机制使得保存的数据尽快恢复缓存

#### 缓存穿透

什么是缓存穿透？

缓存穿透说简单点就是大量请求的key根本不在缓存和数据库中，导致请求直接到了数据库上面。

**正常缓存处理流程：**

![](https://camo.githubusercontent.com/956702a6b60f2428530d4428b4e8e8b6e67f22cb/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312fe6ada3e5b8b8e7bc93e5ad98e5a484e79086e6b581e7a88b2d72656469732e706e67)

**缓存穿透情况处理流程：**

![](https://camo.githubusercontent.com/9d37cdeeaaca84516af626a3c437ed458bd57855/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312fe7bc93e5ad98e7a9bfe9808fe5a484e79086e6b581e7a88b2d72656469732e706e67)





##### 解决办法？

* **缓存无效key：**如果缓存和数据库都查不到某个key的话就写一个到redis中并设置过期时间。这种方式可以解决请求的key变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。
* **布隆过滤器：**布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

![](https://camo.githubusercontent.com/e7b3bd189b985bebae82dbd2adce82f38208aaaf/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312fe5b883e99a86e8bf87e6bba4e599a82de7bc93e5ad98e7a9bfe9808f2d72656469732e706e67)





